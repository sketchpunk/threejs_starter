<!DOCTYPE html><html><head><title></title></head><body><script src="/import-map.js"></script><script type="module">
import Starter, { THREE }    from '../lib/Starter.js';


let App;
let Ref = {};

window.addEventListener( "load", _=>{
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    App = new Starter( { webgl2:false, grid:true, orbit:false } );
    App.setCamera( 0, 20, 6 ); //.render();

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // const axes = axesMesh( { incNegitive:true } );
    // Ref.axes = axes;
    // App.add( axes );

    // Ref.ray = new RayCasting( App.camera, App.renderer ).enable();
    // Ref.ray.onMouseDown  = onMouseDown;
    // Ref.ray.onMouseHover = onMouseHover;

    // const viewport = new ViewportRenderer( App.renderer ).useDefaultLighting();
    // viewport.scene.add( axes );
    // Ref.viewport = viewport;

    // Ref.oGizmo = new OrientationGizmo( App.camera, App.renderer );

    Ref.ctrl = new OrbitCursor( App.camera, App.renderer );
    App.add( Ref.ctrl.cursorMesh );

    Ref.ctrl.updateLook();

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // App.onRenderPost = onRenderPost;
    App.render();
});

import CursorMesh             from '../lib/meshes/CursorMesh.js';
import { vec3, quat }         from 'gl-matrix';
import CanvasPointerHandlers  from '../lib/camera/CanvasPointerHandlers.js';
import CanvasKeyboardHandlers from '../lib/camera/CanvasKeyboardHandlers.js';

import { 
    orbitStep, spherical2cartesian, cartesian2spherical, 
    zoomTarget, 
    lookAt,
    panStepXZ,
} from '../lib/camera/CameraMovements.js';

const AXES = {
    RIGHT  : 0,
    TOP    : 1,
    FRONT  : 2,
    LEFT   : 3,
    BOTTOM : 4,
    BACK   : 5,

    DIR  : [
        [1,0,0],
        [0,1,0],
        [0,0,1],
        [-1,0,0],
        [0,-1,0],
        [0,0,-1],
    ],

    LOOK : [
        [0,-0.7071067811865475,0,0.7071067811865475],
        [0.7071067811865475,0,0,0.7071067811865475],
        [0,-1,0,0],
        [0,0.7071067811865475,0,0.7071067811865475],
        [-0.7071067811865475,0,0,0.7071067811865475],
        [0,0,0,1],
    ],
}


class OrbitCursor{
    cursorMesh    = null;
    targetPos     = [0,0,0];
    camera        = null;
    canvas        = null;
    mouseHandler  = null;
    kboardHandler = null;

    kbStep        = 20;         // Distance to travel per tick of keyboard input

    yStep         = 10;         // Vertical step distance when dealing with mouse input
    stepScale     = 2.0;        // XZ Stepping scale
    zoomScale     = 0.8;        // Zoom scale for scroll wheel
    pinchScale    = 0.95;       // Zoom scale for pinch gesture
    touchpadOrbitScale = 0.5;   // Scale orbit step for touchpad

    initTarget    = [0,0,0];    // Cache target positition
    initPos       = [0,0,0];    // Cache camera position
    initRot       = [0,0,0,1];  // Cache camera rotation

    constructor( camera, renderer ){
        this.cursorMesh = CursorMesh();

        if( camera && renderer ) this.init( camera, renderer );
    }

    init( camera, renderer ){
        this.canvas = renderer.domElement;
        this.camera = camera;

        // Setup Mouse Events
        this.mouseHandler = new CanvasPointerHandlers( this.canvas ).enable()
        this.mouseHandler.onPointerWheel = this.onPointerWheel;
        this.mouseHandler.onPointerDown  = this.onPointerDown;
        this.mouseHandler.onPointerMove  = this.onPointerMove;

        // Setup Keyboard Events
        this.kboardHandler = new CanvasKeyboardHandlers( this.canvas ).enable();
        this.kboardHandler.onKeyDown = this.onKeyDown;

        return this;
    }

    // #region Camera Controls
    setTargetDistance( v ){
        const pos = zoomTarget( this.getCameraPos(), this.targetPos, v );
        this.setPosition( pos );
        return this;
    }

    setPosition( p ){
        this.camera.position.fromArray( p );
        this.updateLook();
        return this;
    }

    setTarget( p ){
        const delta  = vec3.sub( [0,0,0], p, this.targetPos );
        const camPos = this.getCameraPos();

        vec3.add( camPos, camPos, delta );

        this.targetPos = p;
        this.cursorMesh.position.fromArray( p );
        this.setPosition( camPos );
        return this;
    }

    stepOrbit( dx, dy, sx, sy, startPos=this.getCameraPos() ){
        // Delta * Degrees then scaled by canvas height, this makes it possible
        // to rotate a whole X degrees from center to edge of screen
        const rx  = ( dx * Math.PI * sx ) / this.canvas.clientHeight;
        const ry  = ( dy * Math.PI * sy ) / this.canvas.clientHeight; 
        const pos = orbitStep( rx, ry, startPos, this.targetPos );
        this.setPosition( pos );
        return this;
    }

    stepXZ( dx, dz, startPos=this.targetPos.slice() ){
        let dist  = vec3.dist( this.getCameraPos(), this.targetPos );
            dist *= Math.tan( ( this.camera.getEffectiveFOV() * 0.5 ) * 0.01745329251 );

        const x   = dx * this.stepScale * dist / this.canvas.clientHeight;
        const z   = dz * this.stepScale * dist / this.canvas.clientHeight;        
        const pos = panStepXZ( this.camera, x, z, startPos );

        this.setTarget( pos );
    }

    stepY( dy ){
        let dist  = vec3.dist( this.getCameraPos(), this.targetPos );
            dist *= Math.tan( ( this.camera.getEffectiveFOV() * 0.5 ) * 0.01745329251 );

        const y   = dy * this.stepScale * dist / this.canvas.clientHeight;
        const pos = [
            this.targetPos[0],
            this.targetPos[1] + y,
            this.targetPos[2],
        ];

        this.setTarget( pos );
        return this
    }

    getCameraPos(){ return this.camera.position.toArray(); }
    getCameraRot(){ return this.camera.quaternion.toArray(); }

    updateLook(){
        this.camera.quaternion.fromArray( lookAt( [0,0,0], this.getCameraPos(), this.targetPos ) );
    }

    toAxis( i ){
        const li   = ( i + 3 ) % 6; // Index to look in opposite direction
        const dist = vec3.dist( this.getCameraPos(), this.targetPos );
        const pos  = vec3.scaleAndAdd( [0,0,0], this.targetPos, AXES.DIR[ i ], dist );

        // Move camera to the Axis direction of target
        // but rotate look at the opposite direction.
        // For example, placing camera Right of target but looking Left.
        this.camera.position.fromArray( pos );
        this.camera.quaternion.fromArray( AXES.LOOK[ li ] );
        return this
    }
    // #endregion

    // #region MOUSE HANDLERS
    onPointerWheel = ( e, dx, dy )=>{
        // Kind of a hack, not 100% sure that mouse wheels will
        // always generate a deltaY value of 100 or -100. When testing
        // with two fingers the deltas seem to be less then 60 so this 
        // might be a good way to dell the different between mouse or trackpad use.
        const isMouse = ( Math.abs( dy ) > 99 ); 

        if( isMouse || e.ctrlKey ){
             // Browser auto sets ctrlKey true if its a Pinch to Zoom Gesture
            const tick = Math.sign( dy );
            const d    = vec3.dist( this.getCameraPos(), this.targetPos );
            const scl  = ( isMouse )? this.zoomScale : this.pinchScale;

            // Issue, when using pinch gesture, SHIFT and ALT keys won't work
            // So there is no way to augment pinch gestures.
            if( e.shiftKey ){
                // Vertical Movement
                this.stepY( tick * this.yStep );
            }else{
                // Zoom Movement
                this.setTargetDistance( ( tick === -1 )? d * scl : d / scl );
            }
        }else{
            if( e.shiftKey ){
                // If shift, move the target instead of orbiting it
                this.stepXZ( dx, -dy );
            }else{
                // With two fingers on the trackpad will trigger a Wheel event,
                // can take this chance to use it as a way to control the camera orbit
                // instead of zoom.
                this.stepOrbit( dx, -dy, this.touchpadOrbitScale, this.touchpadOrbitScale );
            }
        }
    }; 
    
    onPointerDown  = ( e, coord )=>{
        this.initPos    = this.getCameraPos();
        this.initRot    = this.getCameraRot();
        this.initTarget = this.targetPos.slice();
        return true;
    };

    onPointerMove  = ( e, coord, delta, vel )=>{
        if( e.shiftKey ){
            this.stepXZ( -delta[0], delta[1], this.initTarget );
        }else{
            // Orbit around the target
            this.stepOrbit( -delta[0], delta[1], 2.0, 1.0, this.initPos );
        }
    };
    // #endregion

    // #region KEYBOARD HANDLERS
    onKeyDown = ( e )=>{
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Movement
        const move = this.kboardHandler.getWASDAxes();

        if( move[0] || move[1] ) this.stepXZ( move[0] * this.kbStep, move[1] * this.kbStep );
        if( move[2] )            this.stepY( -move[2] * this.kbStep );

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Orbit
        const spin = this.kboardHandler.getArrowAxes();

        if( e.shiftKey ){
            // Shift + Up/Down to invoke zoom
            if( spin[1] ){
                const d = vec3.dist( this.getCameraPos(), this.targetPos );
                this.setTargetDistance( 
                    ( spin[1] === 1 )? d * this.zoomScale : d / this.zoomScale
                );
            }
        }else{
            // Orbit target
            if( spin[0] || spin[1] ) this.stepOrbit( spin[0], spin[1], 10, 10 );
        }
    };
    // #endregion
}

</script></body></html>